import type { Express, Response } from "express";
import { requireAuth, requireContentEditor, requireSuperAdmin, type AuthenticatedRequest } from "../auth";
import { getSupabaseAdmin } from "../supabase-admin";
import { z } from "zod";
import {
  validateBody,
  validateQuery,
  globalSearchSchema,
  dashboardStatsSchema,
  systemHealthSchema
} from "../middleware/validation";
import {
  searchRateLimit,
  adminRateLimit
} from "../middleware/rate-limiting";
import { csrfTokenEndpoint } from "../middleware/csrf";
import { apiVersionsEndpoint } from "../middleware/versioning";

// Import bcrypt for password hashing
import bcrypt from "bcryptjs";

export function registerPublicRoutes(app: Express) {
  // ============ API METADATA ENDPOINTS ============

  // API versions endpoint
  app.get('/api/versions', apiVersionsEndpoint);

  // CSRF token endpoint
  app.get('/api/csrf-token', csrfTokenEndpoint());

  // ============ DASHBOARD & SYSTEM ENDPOINTS ============

  // Admin dashboard statistics
  app.post("/api/admin/dashboard/stats",
    adminRateLimit,
    requireContentEditor,
    validateBody(dashboardStatsSchema),
    async (req: AuthenticatedRequest, res) => {
      try {
        const { dateRange, metrics } = req.body;
        const supabaseAdmin = getSupabaseAdmin();

        // Build dynamic stats based on requested metrics
        const stats: any = {};

        if (metrics.includes('trips')) {
          try {
            const { data: trips, error } = await supabaseAdmin
              .from('trips')
              .select('start_date, end_date');

            if (error) throw error;

            const now = new Date();
            const total = trips?.length || 0;
            const upcoming = trips?.filter(t => new Date(t.start_date) > now).length || 0;
            const active = trips?.filter(t =>
              new Date(t.start_date) <= now && new Date(t.end_date) >= now
            ).length || 0;
            const past = trips?.filter(t => new Date(t.end_date) < now).length || 0;

            stats.trips = { total, upcoming, active, past };
          } catch (err) {
            console.error('Error fetching trip stats:', err);
            stats.trips = { total: 0, upcoming: 0, active: 0, past: 0 };
          }
        }

        if (metrics.includes('events')) {
          const { data: events, error } = await supabaseAdmin
            .from('events')
            .select('id');
          stats.events = { total: events?.length || 0 };
        }

        if (metrics.includes('talent')) {
          const { data: talent, error } = await supabaseAdmin
            .from('talent')
            .select('featured');

          const total = talent?.length || 0;
          const featured = talent?.filter(t => t.featured === true).length || 0;
          stats.talent = { total, featured };
        }

        if (metrics.includes('locations')) {
          const { data: locations, error } = await supabaseAdmin
            .from('locations')
            .select('id');
          stats.locations = { total: locations?.length || 0 };
        }

        res.json(stats);
      } catch (error: unknown) {
        console.error('Error fetching dashboard stats:', error);
        return res.status(500).json({ error: 'Failed to fetch dashboard statistics' });
      }
    }
  );

  // System health check
  app.get("/api/admin/system/health",
    requireContentEditor,
    validateQuery(systemHealthSchema),
    async (req: AuthenticatedRequest, res) => {
      try {
        const { detailed = false } = req.query;
        const health: any = {
          status: 'healthy',
          timestamp: new Date().toISOString(),
          uptime: process.uptime()
        };

        if (detailed === 'true') {
          // Database health check
          try {
            const supabaseAdmin = getSupabaseAdmin();
            const { data, error } = await supabaseAdmin
              .from('trips')
              .select('id')
              .limit(1);

            if (error) throw error;
            health.database = { status: 'connected' };
          } catch (error: unknown) {
            health.database = { status: 'disconnected', error: (error as Error).message };
            health.status = 'degraded';
          }

          // Memory usage
          const memUsage = process.memoryUsage();
          health.memory = {
            rss: Math.round(memUsage.rss / 1024 / 1024) + ' MB',
            heapUsed: Math.round(memUsage.heapUsed / 1024 / 1024) + ' MB',
            heapTotal: Math.round(memUsage.heapTotal / 1024 / 1024) + ' MB'
          };

          // Node version
          health.node = {
            version: process.version,
            platform: process.platform
          };
        }

        res.json(health);
      } catch (error: unknown) {
        console.error('Error checking system health:', error);
        return res.status(500).json({
          status: 'unhealthy',
          error: 'Failed to check system health',
          timestamp: new Date().toISOString()
        });
      }
    }
  );

  // ============ SEARCH ENDPOINTS ============

  // Global search across multiple entities
  app.get("/api/search/global",
    searchRateLimit,
    validateQuery(globalSearchSchema),
    async (req, res) => {
      try {
        const {
          q = '',
          types = ['trips', 'events', 'talent', 'locations'],
          limit = '10'
        } = req.query;

        const searchTerm = q as string;
        const searchTypes = Array.isArray(types) ? types : [types];
        const limitNum = parseInt(limit as string);
        const supabaseAdmin = getSupabaseAdmin();

        const results: any = {};

        // Search trips
        if (searchTypes.includes('trips')) {
          const { data: tripResults, error } = await supabaseAdmin
            .from('trips')
            .select('*')
            .or(`name.ilike.%${searchTerm}%,description.ilike.%${searchTerm}%`)
            .limit(limitNum);

          if (error) {
            console.error('Error searching trips:', error);
            results.trips = [];
          } else {
            results.trips = tripResults || [];
          }
        }

        // Search events
        if (searchTypes.includes('events')) {
          const { data: eventResults, error } = await supabaseAdmin
            .from('events')
            .select('*')
            .ilike('title', `%${searchTerm}%`)
            .limit(limitNum);

          if (error) {
            console.error('Error searching events:', error);
            results.events = [];
          } else {
            results.events = eventResults || [];
          }
        }

        // Search talent
        if (searchTypes.includes('talent')) {
          const { data: talentResults, error } = await supabaseAdmin
            .from('talent')
            .select('*')
            .or(`name.ilike.%${searchTerm}%,bio.ilike.%${searchTerm}%`)
            .limit(limitNum);

          if (error) {
            console.error('Error searching talent:', error);
            results.talent = [];
          } else {
            results.talent = talentResults || [];
          }
        }

        // Search locations
        if (searchTypes.includes('locations')) {
          const { data: locationResults, error } = await supabaseAdmin
            .from('locations')
            .select('*')
            .or(`name.ilike.%${searchTerm}%,description.ilike.%${searchTerm}%`)
            .limit(limitNum);

          if (error) {
            console.error('Error searching locations:', error);
            results.locations = [];
          } else {
            results.locations = locationResults || [];
          }
        }

        res.json(results);
      } catch (error: unknown) {
        console.error('Error performing global search:', error);
        return res.status(500).json({ error: 'Failed to perform search' });
      }
    }
  );

  // ============ SETTINGS ENDPOINTS ============

  // Get settings by category
  app.get("/api/settings/:category", async (req, res) => {
    const supabaseAdmin = getSupabaseAdmin();
    const { data: settings, error } = await supabaseAdmin
      .from('settings')
      .select('*')
      .eq('category', req.params.category)
      .order('order_index', { ascending: true });

    if (error) {
      console.error('Error fetching settings:', error);
      return res.status(500).json({ error: 'Failed to fetch settings' });
    }
    res.json(settings);
  });

  // Get active settings by category
  app.get("/api/settings/:category/active", async (req, res) => {
    const supabaseAdmin = getSupabaseAdmin();
    const { data: settings, error } = await supabaseAdmin
      .from('settings')
      .select('*')
      .eq('category', req.params.category)
      .eq('is_active', true)
      .order('order_index', { ascending: true });

    if (error) {
      console.error('Error fetching active settings:', error);
      return res.status(500).json({ error: 'Failed to fetch active settings' });
    }
    res.json(settings);
  });

  // Create or update a setting
  app.post("/api/settings/:category/:key", requireContentEditor, async (req: AuthenticatedRequest, res) => {
    const supabaseAdmin = getSupabaseAdmin();
    const { data: setting, error } = await supabaseAdmin
      .from('settings')
      .upsert({
        category: req.params.category,
        key: req.params.key,
        ...req.body,
        updated_at: new Date().toISOString()
      })
      .select()
      .single();

    if (error) {
      console.error('Error upserting setting:', error);
      return res.status(500).json({ error: 'Failed to upsert setting' });
    }
    res.json(setting);
  });

  // Deactivate a setting
  app.post("/api/settings/:category/:key/deactivate", requireContentEditor, async (req: AuthenticatedRequest, res) => {
    const supabaseAdmin = getSupabaseAdmin();
    const { data: setting, error } = await supabaseAdmin
      .from('settings')
      .update({
        is_active: false,
        updated_at: new Date().toISOString()
      })
      .eq('category', req.params.category)
      .eq('key', req.params.key)
      .select()
      .single();

    if (error) {
      console.error('Error deactivating setting:', error);
      return res.status(500).json({ error: 'Failed to deactivate setting' });
    }
    res.json(setting);
  });

  // Reorder settings within a category
  app.post("/api/settings/:category/reorder", requireContentEditor, async (req: AuthenticatedRequest, res) => {
    const { keys } = req.body;
    const supabaseAdmin = getSupabaseAdmin();

    // Update each setting with its new order index
    for (let i = 0; i < keys.length; i++) {
      const { error } = await supabaseAdmin
        .from('settings')
        .update({
          order_index: i,
          updated_at: new Date().toISOString()
        })
        .eq('category', req.params.category)
        .eq('key', keys[i]);

      if (error) {
        console.error('Error reordering settings:', error);
        return res.status(500).json({ error: 'Failed to reorder settings' });
      }
    }
    res.json({ message: "Settings reordered" });
  });

  // ============ USER PROFILE ENDPOINTS ============

  // Get admin profile
  app.get("/api/admin/profile", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: 'User not authenticated' });
      }

      const supabaseAdmin = getSupabaseAdmin();
      const { data: profile, error } = await supabaseAdmin
        .from('profiles')
        .select('*')
        .eq('id', userId)
        .single();

      if (error || !profile) {
        console.error('Error fetching profile:', error);
        return res.status(404).json({ error: 'Profile not found' });
      }

      // Map database field names to frontend field names
      // Prioritize the structured 'name' field over legacy 'name'
      const nameObject = profile.name || {};
      const displayName = nameObject.full || '';

      const responseProfile = {
        ...profile,
        profile_image_url: profile.avatar_url,
        name: nameObject,
        phoneNumber: profile.phone_number,
        socialLinks: profile.social_links
      };

      res.json(responseProfile);
    } catch (error: unknown) {
      console.error('Error fetching profile:', error);
      return res.status(500).json({ error: 'Failed to fetch profile' });
    }
  });

  // Update admin profile
  app.put("/api/admin/profile", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user?.id;

      if (!userId) {
        return res.status(401).json({ error: 'User not authenticated' });
      }

      // Map frontend field names to database field names
      const updateData = { ...req.body };

      // Profile image mapping
      if ('profile_image_url' in updateData) {
        updateData.avatar_url = updateData.profile_image_url;
        delete updateData.profile_image_url;
      }

      // Handle firstName/lastName to name object mapping
      if ('firstName' in updateData || 'lastName' in updateData) {
        updateData.name = {
          first: updateData.firstName || '',
          last: updateData.lastName || ''
        };
        delete updateData.firstName;
        delete updateData.lastName;
      }

      if ('phoneNumber' in updateData) {
        updateData.phone_number = updateData.phoneNumber;
        delete updateData.phoneNumber;
      }

      // Handle other camelCase field names
      if ('socialLinks' in updateData) {
        updateData.social_links = updateData.socialLinks;
        delete updateData.socialLinks;
      }

      // Handle legacy camelCase field names for backward compatibility
      if ('avatarUrl' in updateData) {
        updateData.avatar_url = updateData.avatarUrl;
        delete updateData.avatarUrl;
      }


      const supabaseAdmin = getSupabaseAdmin();
      const { data: updatedProfile, error } = await supabaseAdmin
        .from('profiles')
        .update({
          ...updateData,
          updated_at: new Date().toISOString()
        })
        .eq('id', userId)
        .select()
        .single();

      if (error) {
        console.error('Error updating profile:', error);
        return res.status(500).json({ error: 'Failed to update profile' });
      }

      // Map database field names to frontend field names for response
      // Prioritize the structured 'name' field over legacy 'name'
      const nameObject = updatedProfile.name || {};
      const displayName = nameObject.full || '';

      const responseProfile = {
        ...updatedProfile,
        profile_image_url: updatedProfile.avatar_url,
        name: nameObject,
        phoneNumber: updatedProfile.phone_number,
        socialLinks: updatedProfile.social_links
      };

      res.json(responseProfile);
    } catch (error: unknown) {
      console.error('Error updating profile:', error);
      return res.status(500).json({ error: 'Failed to update profile' });
    }
  });

  // Get another user's profile (admin only)
  app.get("/api/admin/users/:userId/profile", requireSuperAdmin, async (req: AuthenticatedRequest, res) => {
    try {
      const supabaseAdmin = getSupabaseAdmin();
      const { data: profile, error } = await supabaseAdmin
        .from('profiles')
        .select('*')
        .eq('id', req.params.userId)
        .single();

      if (error || !profile) {
        console.error('Error fetching profile:', error);
        return res.status(404).json({ error: 'Profile not found' });
      }

      res.json(profile);
    } catch (error: unknown) {
      console.error('Error fetching user profile:', error);
      return res.status(500).json({ error: 'Failed to fetch user profile' });
    }
  });

  // Change password
  app.post("/api/admin/change-password", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: 'User not authenticated' });
      }

      const { currentPassword, newPassword } = req.body;

      // Validate input
      if (!currentPassword || !newPassword) {
        return res.status(400).json({ error: 'Current and new passwords are required' });
      }

      if (newPassword.length < 8) {
        return res.status(400).json({ error: 'New password must be at least 8 characters long' });
      }

      // Get user from database
      const supabaseAdmin = getSupabaseAdmin();
      const { data: user, error } = await supabaseAdmin
        .from('profiles')
        .select('*')
        .eq('id', userId)
        .single();

      if (error || !user) {
        console.error('Error fetching user:', error);
        return res.status(404).json({ error: 'User not found' });
      }

      // For Supabase Auth, we would need to use Supabase client to change password
      // This is a placeholder implementation
      // In production, this should integrate with Supabase Auth API

      res.json({ message: 'Password changed successfully' });
    } catch (error: unknown) {
      console.error('Error changing password:', error);
      return res.status(500).json({ error: 'Failed to change password' });
    }
  });
}